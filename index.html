<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Impossible Architecture Explorer — Rehaul</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#050608; font-family: Inter, system-ui, sans-serif; }
    #ui { position:fixed; inset:0; pointer-events:none; color:#dbe4ef; display:flex; justify-content:space-between; padding:14px; text-shadow:0 0 12px rgba(0,0,0,.75); }
    #left, #right { display:flex; flex-direction:column; gap:8px; }
    .panel { background:rgba(10,16,24,.45); border:1px solid rgba(160,190,225,.28); border-radius:12px; padding:8px 10px; backdrop-filter: blur(4px); }
    #mapCanvas { width:220px; height:220px; border-radius:12px; border:1px solid rgba(160,190,225,.3); background:rgba(2,6,12,.65); }
    #crosshair { position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); width:14px; height:14px; pointer-events:none; }
    #crosshair:before, #crosshair:after { content:""; position:absolute; background:rgba(220,236,255,.9); box-shadow:0 0 12px rgba(170,210,255,.5); }
    #crosshair:before { left:6px; top:0; width:2px; height:14px; }
    #crosshair:after { left:0; top:6px; width:14px; height:2px; }
    #fx { position:fixed; inset:0; pointer-events:none; z-index:3;
      background:
      radial-gradient(circle at center, rgba(255,255,255,0.0) 45%, rgba(0,0,0,.48) 100%),
      repeating-linear-gradient(0deg, rgba(255,255,255,.02) 0 1px, transparent 1px 3px);
      mix-blend-mode:soft-light;
    }
    #startOverlay { position:fixed; inset:0; display:grid; place-items:center; z-index:10;
      background:radial-gradient(circle at 50% 30%, #121824 0%, #070a10 55%, #030406 100%); color:#dde6f1; }
    #card { max-width:720px; padding:26px; border-radius:16px; border:1px solid rgba(150,190,240,.3); background:rgba(10,14,20,.65); }
    h1 { margin:0 0 8px; font-size:24px; }
    p { margin:8px 0; line-height:1.35; opacity:.95; }
    button { margin-top:14px; border:0; padding:11px 16px; border-radius:10px; font-weight:700; cursor:pointer; color:#051019; background:linear-gradient(135deg,#8ec3ff,#82f0df); }
  </style>
</head>
<body>
  <div id="startOverlay">
    <div id="card">
      <h1>Impossible Architecture Explorer</h1>
      <p>WASD move • Mouse look • Shift sprint • Space jump</p>
      <p>Collect 5 artifacts. Walk through impossible portals. The map lies. The halls remember you.</p>
      <button id="startBtn">Enter</button>
    </div>
  </div>
  <div id="crosshair"></div>
  <div id="fx"></div>
  <div id="ui">
    <div id="left">
      <div class="panel" id="status">Artifacts: 0 / 5</div>
      <div class="panel" id="zone">Zone: Lobby Echo</div>
      <div class="panel" id="hint">Hint: Blue frames are not normal doors.</div>
    </div>
    <div id="right"><canvas id="mapCanvas" width="220" height="220"></canvas></div>
  </div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0b1018, 0.013);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 1.8));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.12;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.setClearColor(0x06090f, 1);
document.body.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(78, innerWidth/innerHeight, 0.03, 800);
const yaw = new THREE.Object3D();
const pitch = new THREE.Object3D();
pitch.add(camera); yaw.add(pitch); scene.add(yaw);
yaw.position.set(0,1.65,2);

let pointerLocked = false;
const keys = new Set();
const velocity = new THREE.Vector3();
let onGround = false;
let gravity = new THREE.Vector3(0,-22,0);
let camRoll = 0;

const startBtn = document.getElementById('startBtn');
const overlay = document.getElementById('startOverlay');
startBtn.onclick = () => renderer.domElement.requestPointerLock();
document.addEventListener('pointerlockchange', ()=>{
  pointerLocked = document.pointerLockElement === renderer.domElement;
  overlay.style.display = pointerLocked ? 'none' : 'grid';
});
document.addEventListener('mousemove', e=>{
  if(!pointerLocked) return;
  yaw.rotation.y -= e.movementX*0.0018;
  pitch.rotation.x -= e.movementY*0.0018;
  pitch.rotation.x = Math.max(-Math.PI/2+0.02, Math.min(Math.PI/2-0.02, pitch.rotation.x));
});
document.addEventListener('keydown', e=>keys.add(e.code));
document.addEventListener('keyup', e=>keys.delete(e.code));

// Lighting rig
scene.add(new THREE.AmbientLight(0x7e92b7, 0.18));
const hemi = new THREE.HemisphereLight(0xbad3ff, 0x241d16, 0.8);
scene.add(hemi);
const moon = new THREE.DirectionalLight(0xcfe3ff, 0.9);
moon.position.set(28,34,9); moon.castShadow = true; moon.shadow.mapSize.set(2048,2048);
scene.add(moon);

const flickerLights = [];

function noiseTexture(size=256, lo=90, hi=60, repeat=[8,8]) {
  const c = document.createElement('canvas'); c.width=c.height=size;
  const ctx = c.getContext('2d');
  const img = ctx.createImageData(size,size);
  for(let i=0;i<img.data.length;i+=4){
    const n = lo + Math.random()*hi;
    img.data[i]=n; img.data[i+1]=n*0.98; img.data[i+2]=n*0.92; img.data[i+3]=255;
  }
  ctx.putImageData(img,0,0);
  const t = new THREE.CanvasTexture(c);
  t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(repeat[0],repeat[1]); t.anisotropy=4;
  return t;
}

const wallTex = noiseTexture(256,145,55,[8,3]);
const floorTex = noiseTexture(256,110,45,[10,10]);

const matWall = new THREE.MeshStandardMaterial({ color:0xd7d2c8, roughness:0.74, metalness:0.02, map:wallTex });
const matFloor = new THREE.MeshStandardMaterial({ color:0x8c8a84, roughness:0.92, metalness:0.0, map:floorTex });
const matCeil = new THREE.MeshStandardMaterial({ color:0xd8d0c2, roughness:0.68, metalness:0.01, map:wallTex });
const matTrim = new THREE.MeshStandardMaterial({ color:0x323948, roughness:0.3, metalness:0.22 });

function makeRoom({w,h,d,x,y,z,tint=0xffffff,name='Zone'}){
  const g = new THREE.Group(); g.position.set(x,y,z); g.userData.zoneName = name;
  const floor = new THREE.Mesh(new THREE.BoxGeometry(w,0.2,d), matFloor.clone());
  floor.material.color.multiply(new THREE.Color(tint)); floor.receiveShadow = true; g.add(floor);

  const ceil = new THREE.Mesh(new THREE.BoxGeometry(w,0.2,d), matCeil.clone());
  ceil.material.color.multiply(new THREE.Color(tint)); ceil.position.y = h; g.add(ceil);

  const walls = [
    [w,h,0.2,0,h/2,-d/2],[w,h,0.2,0,h/2,d/2],[0.2,h,d,-w/2,h/2,0],[0.2,h,d,w/2,h/2,0]
  ];
  for (const [ww,hh,dd,xx,yy,zz] of walls){
    const m = new THREE.Mesh(new THREE.BoxGeometry(ww,hh,dd), matWall.clone());
    m.material.color.multiply(new THREE.Color(tint)); m.position.set(xx,yy,zz); m.castShadow=m.receiveShadow=true; g.add(m);
  }

  const grid = new THREE.GridHelper(Math.max(w,d), Math.floor(Math.max(w,d)), 0x4a5262, 0x36404d);
  grid.position.y = 0.11; grid.material.opacity = 0.22; grid.material.transparent = true; g.add(grid);

  const ring = [
    [w-0.6,0.16,0.12,0,h-0.45,-d/2+0.08],[w-0.6,0.16,0.12,0,h-0.45,d/2-0.08],
    [0.12,0.16,d-0.6,-w/2+0.08,h-0.45,0],[0.12,0.16,d-0.6,w/2-0.08,h-0.45,0]
  ];
  for (const [ww,hh,dd,xx,yy,zz] of ring){
    const t = new THREE.Mesh(new THREE.BoxGeometry(ww,hh,dd), matTrim); t.position.set(xx,yy,zz); g.add(t);
  }

  const stripCount = Math.max(2, Math.floor((w*d)/130));
  for(let i=0;i<stripCount;i++){
    const lx = (i/(stripCount-1||1)-0.5)*(w*0.72);
    const lamp = new THREE.Mesh(new THREE.BoxGeometry(Math.min(5,w*0.28),0.08,0.26),
      new THREE.MeshStandardMaterial({ color:0xe8f3ff, emissive:0x95c8ff, emissiveIntensity:0.55 }));
    lamp.position.set(lx,h-0.22,0); g.add(lamp);
    const pl = new THREE.PointLight(0xb2d4ff, 0.9, Math.max(w,d)*0.95, 2);
    pl.position.set(lx,h-0.5,0); g.add(pl); flickerLights.push(pl);
  }

  scene.add(g); return g;
}

const zones = [];
const lobby = makeRoom({w:18,h:4.4,d:18,x:0,y:0,z:0,tint:0xf4f2ea,name:'Lobby Echo'}); zones.push(lobby);
const vast = makeRoom({w:64,h:11,d:64,x:100,y:0,z:0,tint:0xdeefff,name:'Cathedral Void'}); zones.push(vast);
const loopA = makeRoom({w:9,h:4,d:48,x:-54,y:0,z:0,tint:0xffe5cf,name:'Loop Hall α'}); zones.push(loopA);
const loopB = makeRoom({w:9,h:4,d:48,x:-54,y:0,z:78,tint:0xe8deff,name:'Loop Hall β'}); zones.push(loopB);
const stair = makeRoom({w:24,h:16,d:24,x:0,y:-22,z:80,tint:0xe8ffe9,name:'Escher Stairwell'}); zones.push(stair);

function addColumns(group, w, h, d, count, color){
  const geo = new THREE.CylinderGeometry(0.26,0.3,h-0.25,8);
  const mat = new THREE.MeshStandardMaterial({ color, roughness:0.58, metalness:0.22 });
  for(let i=0;i<count;i++){
    const a = i/count * Math.PI*2;
    const c = new THREE.Mesh(geo, mat);
    c.position.set(Math.cos(a)*(w*0.36),(h-0.25)/2,Math.sin(a)*(d*0.36));
    c.castShadow = true; group.add(c);
  }
}
addColumns(vast,64,11,64,18,0x2f3a4a);
addColumns(stair,24,16,24,12,0x375044);

function scatterProps(group, w,d,count,color){
  const mat = new THREE.MeshStandardMaterial({ color, roughness:0.84, metalness:0.05 });
  for(let i=0;i<count;i++){
    const bw = 0.8+Math.random()*2.2, bh=0.4+Math.random()*1.5, bd=0.8+Math.random()*2.2;
    const p = new THREE.Mesh(new THREE.BoxGeometry(bw,bh,bd), mat);
    p.position.set((Math.random()-0.5)*(w*0.8), bh/2, (Math.random()-0.5)*(d*0.8));
    p.rotation.y = Math.random()*Math.PI; p.castShadow=p.receiveShadow=true; group.add(p);
  }
}
scatterProps(vast,64,64,38,0x4b586c);
scatterProps(stair,24,24,16,0x4f6759);

for(const hall of [loopA, loopB]){
  for(let i=0;i<9;i++){
    const z = -21 + i*5.2;
    const lamp = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.46,1.25),
      new THREE.MeshStandardMaterial({ color:0xd9e8ff, emissive:0x82b5ff, emissiveIntensity:0.62 }));
    lamp.position.set(4.35,2.4,z); hall.add(lamp);
    const l = new THREE.PointLight(0x98c3ff, 0.55, 10, 2);
    l.position.set(3.8,2.2,z); hall.add(l); flickerLights.push(l);
  }
}

// Door frames + portals
function addDoorFrame(group, pos, rotY=0, color=0x7bc4ff){
  const f = new THREE.Group(); f.position.copy(pos); f.rotation.y = rotY;
  const mat = new THREE.MeshStandardMaterial({ color, emissive:0x244a84, emissiveIntensity:0.95, roughness:0.2, metalness:0.45 });
  const a = new THREE.Mesh(new THREE.BoxGeometry(0.2,2.8,0.22), mat);
  const b = new THREE.Mesh(new THREE.BoxGeometry(0.2,2.8,0.22), mat);
  const c = new THREE.Mesh(new THREE.BoxGeometry(1.8,0.2,0.22), mat);
  a.position.set(-0.9,1.4,0); b.position.set(0.9,1.4,0); c.position.set(0,2.7,0); f.add(a,b,c);
  group.add(f); return f;
}

const rt1 = new THREE.WebGLRenderTarget(1024,1024);
const rt2 = new THREE.WebGLRenderTarget(1024,1024);
const pm1 = new THREE.MeshBasicMaterial({ map: rt1.texture, toneMapped:false });
const pm2 = new THREE.MeshBasicMaterial({ map: rt2.texture, toneMapped:false });
function makePortal(mat){ const p = new THREE.Mesh(new THREE.PlaneGeometry(1.8,2.8), mat); p.userData.size = {w:1.8,h:2.8}; return p; }

const f1 = addDoorFrame(lobby, new THREE.Vector3(0,0,-8.9), 0, 0x71c9ff);
const f2 = addDoorFrame(vast, new THREE.Vector3(0,0,31.9), Math.PI, 0x71c9ff);
const p1 = makePortal(pm1); p1.position.set(0,1.4,0.01); f1.add(p1);
const p2 = makePortal(pm2); p2.position.set(0,1.4,0.01); f2.add(p2);
const portals = [{from:p1,to:p2,cooldown:0},{from:p2,to:p1,cooldown:0}];

// Puzzle artifacts
const artifacts=[];
const artifactPos=[new THREE.Vector3(3,1,3),new THREE.Vector3(102,1,-8),new THREE.Vector3(-54,1,38),new THREE.Vector3(-54,1,86),new THREE.Vector3(0,-16,80)];
for(let i=0;i<5;i++){
  const m = new THREE.MeshStandardMaterial({ color:new THREE.Color().setHSL(i*0.2,0.8,0.66), emissive:0x152030, emissiveIntensity:0.75, roughness:0.2, metalness:0.7 });
  const a = new THREE.Mesh(new THREE.IcosahedronGeometry(0.35,0), m);
  a.position.copy(artifactPos[i]); a.castShadow=true; a.userData.collected=false; artifacts.push(a); scene.add(a);
}
let collected=0;

// Watcher shadow
const watcher = new THREE.Mesh(new THREE.SphereGeometry(0.6,14,10), new THREE.MeshBasicMaterial({color:0x000000}));
watcher.visible=false; scene.add(watcher); let watcherTimer=5;

// Ambient procedural audio
let audioCtx;
function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  const master = audioCtx.createGain(); master.gain.value = 0.03; master.connect(audioCtx.destination);
  const o = audioCtx.createOscillator(); const f = audioCtx.createBiquadFilter(); const lfo=audioCtx.createOscillator(); const lfg=audioCtx.createGain();
  o.type='sawtooth'; o.frequency.value=42; lfo.frequency.value=0.08; lfg.gain.value=5;
  lfo.connect(lfg); lfg.connect(o.frequency); f.type='lowpass'; f.frequency.value=145; o.connect(f); f.connect(master); o.start(); lfo.start();
}
addEventListener('click', initAudio, {once:true});

// Map
const map = document.getElementById('mapCanvas'), mctx = map.getContext('2d');
const path = [];
const mapTf = {
  'Lobby Echo':{sx:1,sz:1,r:0,ox:0,oz:0}, 'Cathedral Void':{sx:.22,sz:.22,r:Math.PI*.85,ox:30,oz:-16},
  'Loop Hall α':{sx:1.5,sz:.45,r:Math.PI*.23,ox:-34,oz:18}, 'Loop Hall β':{sx:-1.45,sz:.45,r:Math.PI*.17,ox:-38,oz:-10},
  'Escher Stairwell':{sx:1.1,sz:-1.1,r:Math.PI*1.2,ox:9,oz:28}
};

function inferZone(pos){
  for(const z of zones){ if(new THREE.Box3().setFromObject(z).containsPoint(pos)) return z.userData.zoneName; }
  return 'Interstice';
}
function drawMap(){
  mctx.fillStyle='rgba(5,10,18,.3)'; mctx.fillRect(0,0,220,220);
  mctx.strokeStyle='rgba(130,180,255,.7)'; mctx.lineWidth=1.35; mctx.beginPath();
  for(let i=0;i<path.length;i++){
    const p = path[i], t = mapTf[p.zone]||{sx:1,sz:1,r:0,ox:0,oz:0};
    const x=p.x*t.sx, z=p.z*t.sz; const rx=x*Math.cos(t.r)-z*Math.sin(t.r), rz=x*Math.sin(t.r)+z*Math.cos(t.r);
    const px=110+rx*2+t.ox, py=110+rz*2+t.oz; if(i===0)mctx.moveTo(px,py); else mctx.lineTo(px,py);
  }
  mctx.stroke();
}

const statusEl=document.getElementById('status'), zoneEl=document.getElementById('zone'), hintEl=document.getElementById('hint');
function updateUI(z){
  statusEl.textContent=`Artifacts: ${collected} / 5`; zoneEl.textContent=`Zone: ${z}`;
  hintEl.textContent = collected<5 ? 'Hint: Blue frames are not normal doors.' : 'All artifacts found. The place is awake.';
}

const loopABox = new THREE.Box3(new THREE.Vector3(-57,0,20), new THREE.Vector3(-51,3.8,23));
const loopBBox = new THREE.Box3(new THREE.Vector3(-57,0,98), new THREE.Vector3(-51,3.8,101));
const gravZones=[
  {box:new THREE.Box3(new THREE.Vector3(-12,-1,72),new THREE.Vector3(12,13,88)), g:new THREE.Vector3(0,0,-22), roll:Math.PI*.5},
  {box:new THREE.Box3(new THREE.Vector3(-12,-20,72),new THREE.Vector3(12,-9,88)), g:new THREE.Vector3(0,22,0), roll:Math.PI}
];

function applyBounds(p){ p.x=THREE.MathUtils.clamp(p.x,-130,150); p.y=THREE.MathUtils.clamp(p.y,-34,70); p.z=THREE.MathUtils.clamp(p.z,-130,160); }

function renderPortalTexture(src,dst,target){
  const pc = camera.clone();
  const srcInv = new THREE.Matrix4().copy(src.matrixWorld).invert();
  const rel = new THREE.Matrix4().multiplyMatrices(srcInv, camera.matrixWorld);
  const m = new THREE.Matrix4().multiplyMatrices(dst.matrixWorld, new THREE.Matrix4().makeRotationY(Math.PI)).multiply(rel);
  pc.matrixWorld.copy(m); pc.matrixWorld.decompose(pc.position, pc.quaternion, pc.scale); pc.updateMatrixWorld(true); pc.projectionMatrix.copy(camera.projectionMatrix);
  src.visible=false; renderer.setRenderTarget(target); renderer.render(scene, pc); renderer.setRenderTarget(null); src.visible=true;
}

function portalCross(dt){
  for(const pr of portals){
    pr.cooldown=Math.max(0,pr.cooldown-dt); if(pr.cooldown>0) continue;
    const from=pr.from,to=pr.to; const pos=yaw.position;
    const fp=new THREE.Vector3().setFromMatrixPosition(from.matrixWorld);
    const fn=new THREE.Vector3(0,0,1).applyQuaternion(from.getWorldQuaternion(new THREE.Quaternion()));
    const tn=new THREE.Vector3(0,0,1).applyQuaternion(to.getWorldQuaternion(new THREE.Quaternion()));
    const d = fn.dot(pos.clone().sub(fp)); const inFront = d>-0.2 && d<0.22;
    const local=pos.clone(); from.worldToLocal(local);
    const inside=Math.abs(local.x)<from.userData.size.w*.56 && Math.abs(local.y-1.4)<from.userData.size.h*.55;
    if(inFront && inside){
      const off=pos.clone().sub(fp); const q = new THREE.Quaternion().setFromUnitVectors(fn, tn.clone().negate());
      yaw.position.copy(new THREE.Vector3().setFromMatrixPosition(to.matrixWorld).add(off.applyQuaternion(q)).addScaledVector(tn,1));
      yaw.rotation.y += Math.PI; pr.cooldown=.35; portals.forEach(p=>p.cooldown=Math.max(p.cooldown,.2));
    }
  }
}

let prevYaw=0, turnAccum=0;
const clock = new THREE.Clock();
function animate(){
  const dt = Math.min(clock.getDelta(),0.03);
  const t = clock.elapsedTime;

  scene.fog.density = 0.012 + Math.sin(t*0.07)*0.0018;
  flickerLights.forEach((l,i)=>{ l.intensity = 0.62 + Math.sin(t*2.1 + i*1.3)*0.1 + (Math.random()<0.003 ? -0.2 : 0); });

  let inGrav=false;
  for(const gz of gravZones){
    if(gz.box.containsPoint(yaw.position)){ gravity.lerp(gz.g,0.12); camRoll=THREE.MathUtils.lerp(camRoll,gz.roll,0.08); inGrav=true; break; }
  }
  if(!inGrav){ gravity.lerp(new THREE.Vector3(0,-22,0),0.1); camRoll=THREE.MathUtils.lerp(camRoll,0,0.08); }
  camera.rotation.z = camRoll;

  const f = new THREE.Vector3(0,0,-1).applyQuaternion(yaw.quaternion); f.y=0; f.normalize();
  const r = new THREE.Vector3(1,0,0).applyQuaternion(yaw.quaternion); r.y=0; r.normalize();
  const wish = new THREE.Vector3();
  if(keys.has('KeyW')) wish.add(f); if(keys.has('KeyS')) wish.sub(f); if(keys.has('KeyD')) wish.add(r); if(keys.has('KeyA')) wish.sub(r);
  if(wish.lengthSq()>0) wish.normalize();
  const speed = (keys.has('ShiftLeft')||keys.has('ShiftRight')) ? 8.6 : 5.4;
  velocity.x = THREE.MathUtils.damp(velocity.x, wish.x*speed, 10, dt);
  velocity.z = THREE.MathUtils.damp(velocity.z, wish.z*speed, 10, dt);

  if(keys.has('Space') && onGround){ velocity.y=7.9; onGround=false; }
  velocity.addScaledVector(gravity, dt);
  yaw.position.addScaledVector(velocity, dt); applyBounds(yaw.position);
  if(yaw.position.y < 1.65){ yaw.position.y=1.65; velocity.y=Math.max(0,velocity.y); onGround=true; }

  if(loopABox.containsPoint(yaw.position)){ yaw.position.z += 78; yaw.rotation.y += 0.07; }
  else if(loopBBox.containsPoint(yaw.position)){ yaw.position.z -= 78; yaw.rotation.y -= 0.07; }

  if(yaw.position.distanceTo(new THREE.Vector3(0,-9,80))<3.2 && yaw.position.y>-10) yaw.position.y -= 10.2;
  if(yaw.position.distanceTo(new THREE.Vector3(0,-19,80))<3.2 && yaw.position.y<-16) yaw.position.y += 10.2;

  portalCross(dt);

  for(const a of artifacts){
    a.rotation.y += dt*1.4; a.position.y += Math.sin(t*2.2 + a.position.x)*0.0025;
    if(!a.userData.collected && yaw.position.distanceTo(a.position)<1.2){ a.userData.collected=true; a.visible=false; collected++; }
  }

  const dyaw = Math.abs(THREE.MathUtils.euclideanModulo(yaw.rotation.y - prevYaw + Math.PI, Math.PI*2)-Math.PI);
  turnAccum += dyaw; prevYaw = yaw.rotation.y;
  if(turnAccum > Math.PI*1.3){
    turnAccum=0;
    zones.forEach((z,i)=>z.traverse(o=>{
      if(o.material?.color){ const hsl={h:0,s:0,l:0}; o.material.color.getHSL(hsl); hsl.h=(hsl.h + 0.03 + i*0.003)%1; o.material.color.setHSL(hsl.h,hsl.s,Math.max(.22,Math.min(.82,hsl.l+(Math.random()-.5)*.025))); }
    }));
  }

  watcherTimer -= dt;
  if(watcherTimer<=0){ watcherTimer = 5 + Math.random()*7; const dv=new THREE.Vector3(Math.random()>.5?1:-1,0,-1).normalize().applyQuaternion(yaw.quaternion); watcher.position.copy(yaw.position).add(dv.multiplyScalar(7)); watcher.position.y=yaw.position.y-.9; watcher.visible=true; }
  if(watcher.visible){
    const toW = watcher.position.clone().sub(camera.getWorldPosition(new THREE.Vector3())).normalize();
    if(camera.getWorldDirection(new THREE.Vector3()).dot(toW) > 0.84) watcher.visible=false;
  }

  const z = inferZone(yaw.position); updateUI(z);
  if(path.length===0 || new THREE.Vector2(path[path.length-1].x,path[path.length-1].z).distanceTo(new THREE.Vector2(yaw.position.x,yaw.position.z)) > 0.65){
    path.push({x:yaw.position.x,z:yaw.position.z,zone:z}); if(path.length>900) path.shift();
  }
  drawMap();

  renderPortalTexture(p1,p2,rt1); renderPortalTexture(p2,p1,rt2);
  renderer.render(scene,camera);
  requestAnimationFrame(animate);
}
animate();

addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>